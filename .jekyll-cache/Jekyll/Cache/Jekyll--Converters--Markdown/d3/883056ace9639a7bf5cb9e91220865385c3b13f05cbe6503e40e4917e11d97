I"Æ<p>The aim for the coursework for this module was to develop a game engine based around Entity - Component - System (ECS) architecture, then use the game engine to build a 3D pacman game.</p>

<p>From a graphics point of view, this coursework was relatively easy with only a simple HUD, texture objects and a skybox required. I decided to use this coursework to help practice my knowledge from the 3D Graphics module, on top of the required graphics techniques I decided to add Phong lighting to the game and add a minimap of the â€˜mazeâ€™ to the HUD. At the start of the module I did want to have a go at implementing shadows for this coursework, however by the time I had the core features done, plus a couple of extra features done, I did not have enough time to implement shadows and get it tested.</p>

<p>Of the required graphical techniques I had yet to implement a skybox, while not overly challenging I did initially run into problems where I had the skybox cube rendering at the wrong time, or without depth testing disabled / enabled at the right time, leading to a couple of rendering artifacts. However, once implemented properly the skybox worked no matter where Pacman was.</p>

<p>The minimap proved quite simple to implement, this was achieved by rendering the scene into a framebuffer using a camera above the maze. While there are better ways of achieving the minimap, this showed the location of pacman and the ghosts in relation to the board, which was the main goal for the minimap.</p>

<p>While the game that was being developed was visually a 3D game, all of the objects in the game could only move in two directions X / Z, which ultimately meant that the physics could be simplified to 2D. Each object could be represented using either a circle or a square.</p>

<p>Of all the components / systems in the game the most challenging to write was the artificial intelligence for the ghosts. Each of the ghosts used A* algorithm to build paths to find the player Most of the problems that I had with the AI was with the ghosts moving into walls, leading to the ghost getting stuck until the player moved to a location that caused the algorithm to build a different path. From the start the maze was designed to be 3 units wide, with the ghosts / pacman being 1 unit wide, mainly to prevent collision detection from stopping movement around the board. This proved useful for the AI, the implemented AI was locked to the middle of the path, unless the player was very close to the ghost.</p>

<p>Normally the A* algorithm is good at dealing with concave areas in the map, however whenever the ghost went into a concave area the game would freeze, while unsuccessfully trying to calculate a way out. I believe part of the issue was due to the algorithm trying the same path multiple times, at the time I decided to rewrite most of the AI making sure to include some way of preventing the same path to be taking multiple times, which did seem to resolve the issue.</p>

<p>At first using ECS architecture resulted in the few couple of weeks of development being quite slow, however I quickly realised that most systems / components were very similar, not enough to combine but enough to â€˜templateâ€™. Overall with ECS once I got the hang of it I quite enjoyed that I could quickly make entities knowing that in most cases the Entity will just work as intended.</p>

<p>Knowing what the end game would be, lead to a few design decisions that would hinder development of another game using the same game engine. One of which was input, in my implementation I had a input manager which knew what controls to look for and what they affected. This could easily be fixed by allowing the developer to choose and map the input to a delegate (or other such method).</p>
:ET